{"pages":[{"title":"分 类","text":"","link":"/categories/index.html"},{"title":"标 签","text":"","link":"/tags/index.html"},{"title":"关 于","text":"Live in DaLian","link":"/about/index.html"}],"posts":[{"title":"Mac IDEA启动SpringBoot项目过慢","text":"最近本地新起的SpringBoot项目运行非常慢，能有十几秒，最后通过以下方法进行解决，解决后运行在三四秒左右。 通过hostname命令查看本机hostname1$ hostname 得到如下信息1MacBook-Pro.local 修改host文件1sudo vim /etc/hosts 修改条目如下，注意分隔符是TAB，不是空格12127.0.0.1 localhost MacBook-Pro.local::1 localhost MacBook-Pro.local 也可以通过软件进行修改","link":"/2019/05/06/IdeaSpringBoot/"},{"title":"Launchpad图标修改","text":"最近买了34寸曲面显示器，Launchpad的图标显示比较别扭，所以调整显示的行数与列数。 解决这个问题的方法是通过如下命令： 设置行数与列数123defaults write com.apple.dock springboard-rows -int 4defaults write com.apple.dock springboard-columns -int 7killall Dock 恢复默认行数与列数123defaults delete com.apple.dock springboard-rowsdefaults delete com.apple.dock springboard-columnskillall Dock 删除图标分组还有一个命令是删除图标分组（真心觉得这命令没啥用，没事儿别乱试，重新分组老麻烦了！）12defaults write com.apple.dock ResetLaunchPad -bool TRUEkillall Dock","link":"/2019/06/05/LaunchpadIcon/"},{"title":"搭建个人博客 之 MWeb，服务器和全站Https","text":"MWeb界面简洁和高性能，支持发布协议，可以快速发布写好的文章，MWeb备份配合Docker及七牛，防止数据丢失，重新部署也不会太麻烦，下面介绍MWeb快速部署Hexo文章，Docker创建Nginx容器并配置SSL证书，七牛云图床申请及开启Https。 MWeb使用在那么多md编辑器里之所以喜欢用MWeb有这几个原因： 可以边编辑、预览同开（其实也不看预览，但是必须要开，哈哈～） 可以复制图片到正在编辑的md文件，会在对应目录添加图片副本 可以将图片上传到自己的图床 可以快捷发布到各种服务商：印象，少数派……支持自定义脚本 有外部引用模式 操作简洁 配置七牛云在偏好设置--&gt;发布服务可以看到，对应的填入七牛的空间名称，Access Key，Secret Key，和域名即可。填写好后可以进行验证，上传一张图片看是否成功。 上传图片到七牛云写文章时候直接复制图片粘到md中，文章全部写完后点击右上角分享按钮。 选择把本地图片传至图床。 选择复制 Markdown，图片会上传到所选图床并会复制已经替换成对应域名地址的md文本，将md复制到需要部署的md文件中即可。 注：git要手动上传复制外链 配置发布服务在偏好设置--&gt;发布服务可以看到支持和运行脚本,然后写下对应的hexo部署命令即可。 发布文章到Hexo在需要进行部署的md文件点击右上分享选择对应的发布服务。 MWeb会复制命令到剪切板，直接在弹出的终端里command + V回车就可以运行已经写好的部署命令。 Docker + NginxDocker是一个虚拟化软件，你可以认为是类似：VMware、Virtualbox。对开发来讲总结一个最简单的说法：在 Maven 未产生的年代，jar 包要随着开发项目走到哪里跟到哪里。有了 Maven 写好 pom.xml 即可。此时的 Docker 就好比如 Maven，帮你省去了开发过程中的部署环境差异，你再也不能随便说：你的系统可以运行，我的系统就不行。现在别人连系统都帮你做好了~ Docker安装Nginx容器安装启动Docker（以后会更新Docker详细教程）12sudo yum install docker-ce //安装sudo systemctl start docker //启动 推荐一个替代docker stats的插件 ctop12sudo wget https://github.com/bcicen/ctop/releases/download/v0.7.2/ctop-0.7.2-linux-amd64 -O /usr/local/bin/ctopsudo chmod +x /usr/local/bin/ctop 从Docker仓库拉取最新nginx镜像1docker pull nginx 创建Nginx容器12345678910docker run -v /var/dfile/nginx/nginx.conf:/etc/nginx/nginx.conf -v /var/dfile/nginx:/var/dfile/ -v /var/dfile/nginx/full_chain.pem:/etc/nginx/cert/full_chain.pem -v /var/dfile/nginx/private.key:/etc/nginx/cert/private.key -d -p 80:80 -p 443:443 --name=ng -i -t --restart=always bb7 /bin/bash 进入容器1docker exec -it ng bash Nginx配置nginx的配置文件是/etc/nginx/nginx.conf，配置文件如下（ssl）：123456789101112131415161718192021222324server { listen 443 ssl; server_name localhost; ssl_certificate /etc/nginx/cert/full_chain.pem;#ssl配置 ssl_certificate_key /etc/nginx/cert/private.key;#ssl配置 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { root /var/dfile/hexo;#静态资源文件夹 index index.html index.htm;#静态资源页面 } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } server { listen 80;#监听端口 server_name www.mikecorden.com mikecorden.com; rewrite ^(.*) https://$server_name$1 permanent;#301永久重定向 } 启动nginx1/usr/local/sbin/nginx 修改配置文件要重启nginx1/usr/local/sbin/nginx -s reload 用vim修改nginx.conf太费劲，一般直接本地修改完，SFTP工具拖到服务器nginx容器挂在目录，然后重启。 阿里云本站的域名和服务器都是在阿里云购买。阿里云的交互还是很简单的，比较方便，app做的也还行，现在手机也有内置的控制台了。 域名及解析我把博客部署到了github和自己的服务器上，在域名解析的时候，对于国内线路解析到自己的服务器，国外的线路解析到自己的GitHubPages上，来提高访问速度。 SSL证书申请，全站HTTPSSSL证书是在阿里云申请的，下载的时候 选择nginx版本，在创建nginx容器的时候要映射宿主机的443端口用于ssl。具体配置看👆。全站Https需要本站所有的外链必须为Https，包括加载的js，css等，所有的图片链接也必须为Https。因为Hexo其实就是静态页面，实现起来也简单。下面介绍下七牛云图床开启https。 七牛云七牛云提供 10 G/月的标准存储 CDN 回源流量免费额度， 超过按0.15 元/GB 价格进行收费。每个月免费10G对于这种没人看的小博客很够用了，哈哈～ 配置七牛云图床注册七牛云账号，申请对象存储空间（公开空间）。 进入所申请的空间，绑定域名（自动跳转域名管理）。 输入域名，先申请http，保存后进入域名管理，（保存成功后再改为https，这样可以免去手动配置ssl证书）。 状态变为成功后（一般10分钟左右），选择对应的域名，进入配置界面。 配置防盗链白名单，然后配置Https：选择免费证书（阿里云等其他网站申请，点击已有证书），七牛云会自动帮你申请一年有效的免费ssl证书并配置好，最后开启强制Https即可。 最后在域名管理找到域名对应的CNAME值，在阿里云上配置域名解析，类型为CNAME。 最后到此，整个流程结束，现在在MWeb的资源库写笔记，需要发到博客上的直接上传图床复制到外部引用模式对应md中，直接部署生效。也不需要担心备份等突发情况，MWeb支持3个地方的备份，我在Mac本机有备份，在iCloud网盘也有备份，永远不会担心资料丢失了～","link":"/2019/03/18/Hexo2/"},{"title":"Spring Cloud Bus","text":"主要介绍Spring Cloud Bus github上配置文件 Spring Cloud Bus 概述Spring Cloud Bus 使用轻量级的消息代理（RabbitMQ,Kafka……）连接分布式系统的节点（clients），这样可以广播传播状态的更改（更新配置文件操作）或其他管理指令。达到下图效果。例如上图，所有client都与消息总线想连，当configserver的/bus/refresh接收到请求，会像消息总线发送一个配置更新的事件，通过消息总线广播，所有的client会去configServer拉最新的配置。 Client如何更新配置–&gt;refresh客户端如何去主动获取新的配置信息呢，springcloud已经给我们提供了解决方案，每个客户端通过POST方法触发各自的/refresh Client添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-actuator是一套监控的功能，可以监控程序在运行时状态，其中就包括/refresh的功能。 开启更新机制需要给加载变量的类上面加载@RefreshScope，在客户端执行/refresh的时候就会更新此类下面的变量值。 所有的客户端和服务端都需要的依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; ConfigServer配置文件在configServer配置文件增加：1234567891011121314151617181920212223spring: application: name: Config-Server cloud: config: server: git: uri: https://github.com/****/first-config-repo search-paths: /first username: *** password: *** prefix: /config # 访问yml时候http://hostname:port/config/test/dev即可 rabbitmq: host: 0.0.0.0 # RabbitMQ服务地址 port: 5672 username: *** password: *** management: endpoints: web: exposure: include: bus-refresh # 暴露/bus/refresh端点 可以把所有端点都暴露，用*就可以，但yml中的*需要用双引号括起–&gt;&quot;*&quot;,SpringBoot 2.0.x暴露端点方式：1234# 启用端点 envmanagement.endpoint.env.enabled=true# 暴露端点 env 配置多个,隔开management.endpoints.web.exposure.include=env 已经弃用：management.security.enabled=false client配置文件在bootstrap.yml中增加：1234567891011121314151617spring: cloud: config: name: test # application profile: dev # profile label: master # git分支 discovery: service-id: EUR-SERVER2 # 指定server端的name,也就是server端spring.application.name的值 enabled: true # 开启Config服务发现支持 bus: trace: enabled: true # 开启消息跟踪 rabbitmq: host: 0.0.0.0 port: 5672 username: *** password: *** 其中spring.cloud.config.discovery.*下的配置是为了实现配置中心高可用，也可以指定configServer的地址(此方式不是高可用)：spring.cloud.config.uri: http://peer2:8882 WebHook可以在github上设置，码云也可以，push后可以发送一个Post请求。本地验证可以用HTTP工具自己发http://peer1:8881/actuator/bus-refresh（其中actuator别忘了，经常忘写） 验证当更新github上的文件后，手动发送一个post请求http://peer1:8881/actuator/bus-refresh，这时候再验证client中对应的属性值就会发现已经更改了。","link":"/2019/03/01/SpringCloudBus/"},{"title":"Spring Cloud Eureka","text":"主要介绍Spring Cloud Eureka 服务发现组件概述 各个服务启动时候，将自己注册到注册中心，服务发现组件（Eureka Server）会记录这些信息。 服务消费之可以到服务发现组件（Eureka Server）的注册表查询服务提供者的信息（地址等……），并使用该信息调用提供者的接口 各个微服务使用心跳机制与服务发现组件（Eureka Server）进行通信，服务发现组件长时间没有接收到心跳，会注销该服务实例。 微服务更改信息（IP地址等）会重新进行注册，服务消费者可直接获取最新信息。 Spring Cloud服务发现组件有：Eureka，Zookeeper，Consul…… Eureka概述 Netflix开发的服务发现组件，基于REST的服务。包含：Server、Client。 Spring Cloud将其集成于Spring Cloud Netflix中。 Eureka 2.0以上已经闭源。 Eureka原理概述 Eureka Server提供服务发现能力。 Eureka Client是一个Java客户端，会周期性（默认30s）向Eureka Server 发送心跳。 Eureka Server一定时间（默认90s）内没有接收到心跳会注销掉该实例。 默认情况下Eureka Server也是一个Eureka Client（用于高可用），多个Eureka Server互相注册，会通过复制的方式来同步注册表。 Eureka Client也会缓存注册表信息（避免Eureka Server挂掉，无法调用服务提供者） 创建Eureka Serverpom.xml12345&lt;!-- EurekaServer --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 启动类增加@EnableEurekaServer注解 配置文件application.yml123456789101112131415server: port: 8002spring: application: name: Eureka-Servereureka: client: registerWithEureka: true #是否将自己注册到注册中心 fetchRegistry: true #高可用设置，作用：从其他EurekaServer上复制注册表 service-url: defaultZone: http://admin:admin1@peer1:8001/eureka/ #可以配置多个地址，用逗号分隔 instance: hostname: peer2 高可用Eureka Server因为Eureka Server本身也是一个Eureka Client，互相注册，配置文件设置eureka.client.regsiterWithEureka=true,eureka.client.fetchRegistry=true即可。 添加用户认证引入依赖12345&lt;!-- 登陆验证 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 Spring Cloud 2.x以后 12345spring: security: user: name: admin password: 123456 Srong CLoud 1.x 123456security: base: enable: true user: name: admin password: 123456 关闭crsf验证设置安全验证后，由于Spring Cloud 2.x是默认开启crsf验证的，所以一点要关闭crsf，否则client是无法注册到eureka server的。1234567891011121314151617@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { //覆盖父类的 configure(HttpSecurity http) 方法，关闭掉 csrf //如果不关闭，服务将无法注册到此注册中心 //http.csrf().disable();默认是formLogin()，登陆时候不弹窗 http.csrf() .disable() .authorizeRequests() .anyRequest().authenticated() .and() .httpBasic();//httpBasic登陆模式（弹出框） super.configure(http); }} 用户认证下Eureka Client的配置更改defaultZone：erueka.client.service-url.defaultZone: http://{name}:{password}@{host}:{port}/eureka 其他 eureka.instance.prefer-ip-address=true表示将自己的IP注册到Eureka Server，false会将微服务所在的操作系统HOSTNAME注册到Eureka Server eureka.instance.metadate-map.my-metadata=***（key，value随便写）,可以自定义Eureka Server元数据，例如“my-metadata=***”。 自我保护模式，当Eureka Serve节点短时间丢失过多客户端时候，这个节点就会进入自我保护模式，，此时，Eureka Server会保护注册表中的信息，不再删除，故障恢复后节点会自动退出自我保护模式。 多网卡环境下IP选择： 12345678910111213spring: client: inetutils: #忽略docker0网卡和所有veth开头的网卡 ignored-interfaces: - docker0 - veth.* #允许的网络地址 preferredNetworks: - 192.168 - 10.0 #只允许使用站点本地的地址 useOnlySiteLocalInterfaces: true 健康检查状态有：UP，DOWN，OUT_OF_SERVICE，UNKNOWN显示错误，看看健康检查是否开启eureka.client.healthcheck.enabled=true 创建Eureka Clientpom.xml12345&lt;!-- Eureka client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 启动类增加@EnableDiscoveryClient注解 配置文件1234567891011server: port: 9001spring: application: name: Producer eureka: client: serviceUrl: defaultZone: http://admin:123456@peer1:8001/eureka/ 启动Eureka Client可以看到已经注册成功。","link":"/2019/02/05/SpringCloudEureka/"},{"title":"微服务概念类知识","text":"关于CAP理论CAP定理指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。 一致性：C在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时） 可用性：A负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间） 分区容错性：P分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好） CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡 其他问题 满足CA，不能满足P原因：数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足 满足CP，不能满足A原因：数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足 满足AP，不能满足C原因：机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足 注册中心选择 Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足 Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化 结论：分布式系统中P,肯定要满足，所以只能在CA中二选一。没有最好的选择，最好的选择是根据业务场景来进行架构设计。 如果要求一致性，则选择zookeeper，如金融行业如果要去可用性，则Eureka，如电商系统 云计算模式:三种主流模式 名称 全称 翻译 PaaS Platform as a Service 平台即服务 IaaS Infrastructure sa a Service 基础设施即服务 SaaS Software as a Service 软件即服务 结合例子理解在《Spring Microservices in Action》有这样一个例子：当你想吃饭时，你有4种模式： 在家做饭。 去杂货店买一顿先做好的食物，然后你加热并享用。 叫外卖送到家里。 开车去餐厅吃饭。 这些选择之间主要的区别在于：谁负责烹饪，以及在哪烹饪。 上述第一条，想要在家里吃饭，就需要自己做所有的工作，家里的食材，器材。 上述第二条，去商店买，自己加热吃，是使用店内的厨师和器材先做好餐点，但你仍有责任要加热，食用，清洗餐具——&gt;IaaS。 上述第三条，外卖，自己提供盘子，家具，但餐厅提供烤箱、食材、厨师——&gt;PaaS 上述第四条，你去一个餐厅吃饭，什么都不需要做，你就是供应商所提供服务的被动消费者，无法对技术进行选择，同时没有责任维护应用程序的基础设施——&gt;SaaS IaaS也就是基础设施即服务（Infrastructure-as-a-Service），拥有了IaaS，就可以将引荐外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，也可以选择租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。目前比较知名的IaaS公司有亚马逊、Bluelock、CSC、GoGrid、IBM等。 PaaS即软件即服务（Platform-as-a-Service），某些时候也被叫作中间件。所有的开发都可以在这一层进行，节省时间与资源。PaaS公司可以提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统等，可以节省硬件上的费用。PaaS公司与IaaS公司有许多重叠，除了上面列出的那些之外，还有Google、Microsoft Azure、Force.com、,Heroku、Engine Yard等。 最后则是SaaS，软件即服务（Software-as-a-Service），也是我们目前普通用户接触最多的层面，在网络上任意一个远程服务器上的应用都是属于SaaS。比如现在阿里的钉钉、JIBUU以及苹果的iCloud都属于这一类。比较知名的SaaS公司有Salesforce、workday、Slack等。 新兴的云平台 FaaS 函数即服务 CaaS 容器即服务，例如Docker微服务概念的重点在于 构建 有限职责的 小型服务 ，并使用基于HTTP的接口进行通讯。FAAS、CaaS是部署微服务的替代基础设施机制","link":"/2019/02/01/MicroServices/"},{"title":"MacOS JDK，使用Jenv管理本地JDK版本","text":"MacOS上配置JDK环境（附带下载地址），并使用Jenv快速高效的管理本地环境变量JDK版本。 Mac JDK下载 mac版本 jdk 1.6 需要到苹果开发者网站下载 mac版本 jdk 1.7 需要到网上找资源，官方已经停止jdk 1.7的下载链接 mac版本 jdk 1.8 直接到官方网站下载即可 homebrew 使用brew install java 安装会直接安装jdk 10（最新版本） 1brew install java JDK安装目录命令查询1/usr/libexec/java_home -V 卸载JDK执行命令：123456789sudo rm -fr ~/Library/Application\\ Support/Javasudo rm -rf /Library/Java/JavaVirtualMachines/jdk&lt;version&gt;.jdksudo rm -rf /Library/PreferencePanes/JavaControlPanel.prefPanesudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpanesudo rm -rf /Library/Internet\\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -rf /Library/LaunchAgents/com.oracle.java.Java-Updater.plistsudo rm -rf /Library/PrivilegedHelperTools/com.oracle.java.JavaUpdateHelpersudo rm -rf /Library/LaunchDaemons/com.oracle.java.Helper-Tool.plistsudo rm -rf /Library/Preferences/com.oracle.java.Helper-Tool.plist 使用Jevn管理MacOS JDKJenv概述jEnv is a command line tool to help you forget how to set the JAVA_HOME environment variable 安装（zsh下）使用homebrew安装1brew install jenv 添加环境变量12echo &apos;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&apos; &gt;&gt; ~/.zshrcecho &apos;eval &quot;$(jenv init -)&quot;&apos; &gt;&gt; ~/.zshrc 添加jdk版本使用jevn add jdk安装路径，例如：1jenv add /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 常用操作查看所有本地jdk版本1$ jenv versions 设置全局jdk版本1$ jenv global 1.7 设置本地jdk版本 (可以为每个文件夹单独设置版本)1$ jenv local 1.8 设置shell中的jdk版本1$ jenv shell 1.8 配置JVM Options（全局，本地，shell）123jenv global-options &quot;-Xmx512m&quot;jenv local-options &quot;-Xmx512m&quot;jenv shell-options &quot;-Xmx512m&quot;","link":"/2018/07/16/MacJDK/"},{"title":"搭建个人博客 之 Hexo基础","text":"一直有在本地写md笔记的习惯，又想同步到自己的各个设备随时查看，Win平台试过马克飞象同步到印象笔记，印象笔记端不能编辑，放弃……之后一直使用typora在本地保存，自从18年换到MacOS平台后，尝试过MWeb，Quiver，Bear，Ulysses，最后选择MWeb。后来有了自己的服务器，使用了WordPress一段时间，感觉比较麻烦，速度也不理想。折腾向的我又选择了Hexo，所以有了这篇文章，哈哈。现在是采用MWeb编辑md文件，通过MWeb发布服务直接推到服务器上，图片通过MWeb上传到七牛云，服务器使用Docker和Nginx来实现。这样一来，写完md文件后，直接发布，相当方便哈哈！ 安装HexoMac已经使用HomeBrew安装了node和git，所以直接安装Hexo。1npm install -g hexo 新建并进入Hexo目录，并执行Hexo初始化。 1hexo init //hexo初始化 123hexo g //重新生成博客静态文件hexo g --watch//重新生成博客代码(只对变动的文件生成静态文件)hexo s //启动hexo服务 可以在http://localhost:4000看到本地的hexo博客。 使用Hexo写作1hexo new [layout] &lt;title&gt; layout有三种布局： post 文章 page 页面 draft 草稿 三种布局的模版在Hexo目录/scaffolds/下，可以根据需要进行修改，正文部分可以使用md格式也可以使用html格式。 配置Hexo站点在Hexo目录下的_config.yml是Hexo的站点配置文件，注意每个冒号后要有空格，这是我做更改的配置，其余都为默认。1234567891011121314151617181920212223242526# Sitetitle: Corden Web //网站标题subtitle: Web developer, lifelong learner //网站副标题description: //网站描述keywords: //网站关键词author: MikeCorden //作者language: zh-CN //语言timezone: //时区，默认你电脑的时区## Themes: https://hexo.io/themes/theme: next //使用next主题# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: //同时部署到阿里云服务器和git上- type: sftp //部署方式 host: //服务器ip user: //用户名 pass: //密码 remotePath: //上传路径 port: //端口 agent: $SSH_AUTH_SOCK- type: git //部署方式 repo: //git上仓库地址 branch: //分支名称 message: //提交信息 如果只部署到服务器上(更多方式请参考 : hexo.io) ：123deploy: type: sftp ... 使用Hexo主题主题可以在hexo.themes上选择并下载，默认主题是landscape，我下载了Modernist和NexT。 安装NexT主题进入Hexo目录。1git clone git@github.com:theme-next/hexo-theme-next.git themes/next 修改Hexo路径下站点配置文件_config.yml。1theme: next //next需要与themes下对应的主题文件夹同名 配置NexT主题在Hexo目录下cd themes/next可以看到_config.yml，这个是NexT主题的配置文件，注意不要跟Hexo的站点配置文件搞混。 👇简单介绍一些我使用的配置： 菜单配置12345678910# Usage: `Key: /link/ || icon`menu: home: / || home archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 设置后需要在Hexo主目录下创建页面： 1hexo new page tags 如果引入评论系统要在页面加上comments: false（分类和关于页面也要加） 更改主题布局四种布局可选，打开所需布局即可。12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 联系方式12345social: GitHub: https://github.com/yourname || github E-Mail: mailto:&lt;yourmail&gt; || envelope Instagram: https://instagram.com/&lt;你的Ins用户名&gt; || instagram ... 头像123456# Sidebar Avataravatar: url: #头像地址 rounded: false #true--&gt;圆的 opacity: 1 #透明度 rotated: false #true--&gt;鼠标放上旋转 url可以是OSS外链，也可以在主题下的source/images/下放置头像文件即可。 边栏123sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left 自带动画效果123motion: enable: true #开启 async: true #开启异步 开启动画会影响打开网站速度，可以关闭 自带动画背景效果1234567canvas_nest: enable: true #开启 onmobile: false #手机端是否显示 color: \"0,0,0\" #线条颜色 opacity: 0.5 #透明度 zIndex: -1 #z轴坐标 count: 99 #线的数量 NexT主题自带动画canvas_nest或three_waves，根据需求设置值为true或者false即可。 fancybox图片放大12git clone https://github.com/theme-next/theme-next-fancybox3 /themes/next/source/lib/fancybox 在NexT主题配置文件中设置fancybox: true即可。 自定义行内代码样式进入themes/next/source/css/_custom修改custom.styl文件即可。12345678code { color: #c7254e; background: #f9f2f4; border: 1px solid #d6d6d6; padding:1px 4px; word-break: break-all; border-radius:4px;} 百度统计分析 注册百度统计，并新建网站列表。 建立成功后，获取新版统计代码。 将上图中黑色遮挡的ID复制到NexT配置文件,即可开启。 1baidu_analytics: Your Baidu Analytics ID 百度统计的自动代码检测可能检测不到代码装载，可以进行手动检查。 不蒜子阅读量统计在NexT配置文件开启即可。12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 评论系统ValineNexT已经集成了Valine，在主题的配置文件中就可以找到。Valine是基于LeanCloud的，所以需要先申请LeanCloud。 在LeanCloud创建应用。 获取AppId和AppKey 在NexT主题配置文件找到valine并配置 12345678910111213valine: enable: true #开启 appid: #leancloud appid appkey: #leancloud appkey notify: false #邮件通知,参考:https://github.com/xCss/Valine/wiki verify: false #验证码 placeholder: ヾﾉ≧∀≦)o 来呀！快活呀！~ #placeholder文本 avatar: mm #评论头像，参考:https://valine.js.org/avatar.html guest_info: nick,mail #评论标题，link(网址) pageSize: 10 #每页数量 language: #语言:en, zh-cn visitor: false #阅读量 comment_count: true #true首页显示每篇文章评论数 使用Valine阅读量统计需要注意：leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors’ for counter compatibility. Article reading statistic 评论效果👇： 最后到此，Hexo和NexT主题配置结束，下一篇文章将介绍markdown编辑器MWeb快速部署Hexo文章，Docker创建Nginx容器，以及七牛云图床申请，ssl证书等设置。","link":"/2019/03/17/Hexo/"},{"title":"FreeMarker指令常用标签及语法","text":"复习FreeMarker，结合网上资料整理了一下常用的指令与语法，以备日后查看。 FreeMarker Template Language(FTL),文件一般保存为xxx.ftl。严格依赖MVC模式，不依赖Servlet容器（不占用JVM内存），使用内建函数。 注意：使用freemaker，要求所有标签必须闭合，否则会导致freemaker无法解析。freemaker注释:&lt;#– 注释内容 –&gt;格式部分,不会输出 基础语法 字符输出 1234${emp.name?if_exists} // 变量存在，输出该变量，否则不输出${emp.name!} // 变量存在，输出该变量，否则不输出${emp.name?default(&quot;xxx&quot;)} // 变量不存在，取默认值xxx ${emp.name!&quot;xxx&quot;} // 变量不存在，取默认值xxx 常用内部函数： 12345${&quot;123&lt;br&gt;456&quot;?html} // 对字符串进行HTML编码，对html中特殊字符进行转义 ${&quot;str&quot;?cap_first} // 使字符串第一个字母大写 ${&quot;Str&quot;?lower_case} // 将字符串转换成小写 ${&quot;Str&quot;?upper_case} // 将字符串转换成大写 ${&quot;str&quot;?trim} // 去掉字符串前后的空白字符 字符串的两种拼接方式拼接： 12$ { “你好$ {emp.name！}”} //输出你好+变量名 $ {“hello”+ emp.name！} //使用+号来连接，输出你好+变量名 可以通过如下语法来截取子串： 12345678&lt;#assign str =“abcdefghijklmn”/&gt;//方法1$ {str?substring（0,4）} //输出abcd//方法2 $ {str[0]}${str[4]} //结果是ae$ {str [1..4]} //结果是bcde//返回指定字符的索引$ {str?index_of（&quot;n&quot;）} 日期输出 1$ {emp.date?string（&apos;yyyy -MM-dd&apos;）} //日期格式 数字输出（以数字20为例） 123456789101112131415161718192021222324252627$ {emp.name?string.number} //输出20 $ {emp.name?string.currency} //¥20.00 $ {emp.name?string.percent} // 20％ $ {1.222？int} //将小数转为int，输出1 &lt;#setting number_format =“percent”/&gt; //设置数字默认输出方式（&apos;percent&apos;，百分比） &lt;#assign answer = 42 /&gt; //声明变量回答42 #{answer} //输出4,200％$ {answer？string} //输出4,200％$ {answer？string.number} //输出42$ {answer？string.currency} //输出¥42.00 $ {answer？string.percent} //输出4,200％#{answer} //输出42 数字格式化插值可采用＃{expr; format}形式来格式化数字，其中格式可以是：mX：小数部分最小X位MX：小数部分最大X位如下面的例子：&lt;#assign x = 2.582 /&gt; &lt;#assign y = 4 /&gt; ＃ {x; M2} //输出2.58 ＃ {y; M2} //输出4 ＃ {x; m2} //输出2.58 ＃{Y; m2} //输出4.0＃ {x; m1M2} //输出2.58 ＃ {x; m1M2} //输出4.0 申明变量 12&lt;#assign foo = false /&gt; //声明变量，插入布尔值进行显示，注意不要用引号$ {foo？string（“yes”，“no”）} //当为真时输出“yes”，否则输出“no” 申明变量的几种方式 1234567891011&lt;#assign name = value&gt; &lt;#assign name1 = value1 name2 = value2 ... nameN = valueN&gt; &lt;#assign same as above... in namespacehash&gt; &lt;#assign name&gt; capture this &lt;/＃assign&gt; &lt;#assign name in namespacehash&gt; capture this &lt;/＃assign&gt; 比较运算算符 12345表达式中支持的比较运算符符如下几个：=或==：判断两个值是否相等。！=：判断两个值是否不等。&gt;或gt：判断左边值是否大于右边值&gt;&lt;=或lte：判断左边值是否小于等于右边值 算术运算符 123456FreeMarker表达式中完全支持算术运算，FreeMarker支持的算术运算符包括：+， - ，*，/，％注意：（1）运算符两边必须是数字（2）使用+运算符时，如果一边是数字，一边是字符串，就会自动将数字转换为字符串再连接， 如：$ {3 +“5”}，结果是：35 逻辑运算符 12345逻辑运算符有如下几个：逻辑与：&amp;&amp; 逻辑或：|| 逻辑非：！逻辑运算符只能作用于布尔值，否则将产生错误 FreeMarker中的运算符优先级如下（由高到低排列）： 123456789①，一元运算符：！②，内建函数：③，乘除法：*，/，％④，加减法： - ，+ ⑤，比较：&gt;，&lt;，&gt; =，&lt;=（lt，lte，gt，gte）⑥，相等：==，=， ！= ⑦，逻辑与：&amp;&amp; ⑧，逻辑或：|| ⑨，数字范围：.. 实际上，我们在开发过程中应该使用括号来严格区分，这样的可读性好，出错少 if逻辑判断（注意：elseif不加空格） 1234567891011121314151617181920&lt;#if condition&gt;...&lt;#elseif condition2&gt;...&lt;#elseif condition3&gt;...&lt;#else&gt;...&lt;/#if&gt;if 空值判断// 当 photoList 不为空时&lt;#if photoList??&gt;...&lt;/#if&gt; 值得注意的是,${..}只能用于文本部分,不能用于表达式,下面的代码是错误的:&lt;#if ${isBig}&gt;Wow!&lt;/#if&gt;&lt;#if &quot;${isBig}&quot;&gt;Wow!&lt;/#if&gt;// 正确写法&lt;#if isBig&gt;Wow!&lt;/#if&gt; switch (条件可为数字，可为字符串) 12345678910111213&lt;#switch value&gt; &lt;#case refValue1&gt; ....&lt;#break&gt; &lt;#case refValue2&gt; ....&lt;#break&gt; &lt;#case refValueN&gt; ....&lt;#break&gt; &lt;#default&gt; .... &lt;/#switch&gt; 集合 &amp; 循环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 遍历集合:&lt;#list empList! as emp&gt; ${emp.name!}&lt;/#list&gt;// 可以这样遍历集合:&lt;#list 0..(empList!?size-1) as i&gt; ${empList[i].name!}&lt;/#list&gt;// 与jstl循环类似,也可以访问循环的状态。empList?size // 取集合的长度emp_index: // int类型，当前对象的索引值 emp_has_next: // boolean类型，是否存在下一个对象// 使用&lt;#break&gt;跳出循环&lt;#if emp_index = 0&gt;&lt;#break&gt;&lt;/#if&gt;// 集合长度判断 &lt;#if empList?size != 0&gt;&lt;/#if&gt; // 判断=的时候,注意只要一个=符号,而不是==&lt;#assign l=0..100/&gt; // 定义一个int区间的0~100的集合，数字范围也支持反递增,如100..2&lt;#list 0..100 as i&gt; // 等效于java for(int i=0; i &lt;= 100; i++) ${i}&lt;/#list&gt;// 截取子集合：empList[3..5] //返回empList集合的子集合,子集合中的元素是empList集合中的第4-6个元素// 创建集合：&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;// 集合连接运算,将两个集合连接成一个新的集合&lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;// 除此之外,集合元素也可以是表达式,例子如下:[2 + 2, [1, 2, 3, 4], &quot;whatnot&quot;]// seq_contains：判断序列中的元素是否存在&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;]&gt; ${x?seq_contains(&quot;blue&quot;)?string(&quot;yes&quot;, &quot;no&quot;)} // yes${x?seq_contains(&quot;yellow&quot;)?string(&quot;yes&quot;, &quot;no&quot;)} // no${x?seq_contains(16)?string(&quot;yes&quot;, &quot;no&quot;)} // yes${x?seq_contains(&quot;16&quot;)?string(&quot;yes&quot;, &quot;no&quot;)} // no// seq_index_of：第一次出现的索引&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;, &quot;blue&quot;]&gt; ${x?seq_index_of(&quot;blue&quot;)} // 2// sort_by：排序（升序）&lt;#list movies?sort_by(&quot;showtime&quot;) as movie&gt;&lt;/#list&gt;// sort_by：排序（降序）&lt;#list movies?sort_by(&quot;showtime&quot;)?reverse as movie&gt;&lt;/#list&gt;// 具体介绍：// 不排序的情况：&lt;#list movies as moive&gt; &lt;a href=&quot;${moive.url}&quot;&gt;${moive.name}&lt;/a&gt;&lt;/#list&gt;//要是排序，则用&lt;#list movies?sort as movie&gt; &lt;a href=&quot;${movie.url}&quot;&gt;${movie.name}&lt;/a&gt;&lt;/#list&gt;// 这是按元素的首字母排序。若要按list中对象元素的某一属性排序的话，则用&lt;#list moives?sort_by([&quot;name&quot;]) as movie&gt; &lt;a href=&quot;${movie.url}&quot;&gt;${movie.name}&lt;/a&gt;&lt;/#list&gt;//这个是按list中对象元素的[name]属性排序的，是升序，如果需要降序的话，如下所示：&lt;#list movies?sort_by([&quot;name&quot;])?reverse as movie&gt; &lt;a href=&quot;${movie.url}&quot;&gt;${movie.name}&lt;/a&gt;&lt;/#list&gt; Map对象 12345678910// 创建map&lt;#assign scores = {&quot;语文&quot;:86,&quot;数学&quot;:78}&gt;// Map连接运算符&lt;#assign scores = {&quot;语文&quot;:86,&quot;数学&quot;:78} + {&quot;数学&quot;:87,&quot;Java&quot;:93}&gt;// Map元素输出${emp.name} // 全部使用点语法${emp[&quot;name&quot;]} // 使用方括号循环//遍历集合：&lt;＃list empList！as emp&gt; $ {emp.name！} FreeMarker支持如下转义字符: 1234567891011121314151617\\&quot; ：双引号(u0022)\\&apos; ：单引号(u0027)\\\\ ：反斜杠(u005C)\\n ：换行(u000A)\\r ：回车(u000D)\\t ：Tab(u0009)\\b ：退格键(u0008)\\f ：Form feed(u000C)\\l ：&lt;\\g ：&gt;\\a ：&amp;\\{ ：{\\xCode ：直接通过4位的16进制数来指定Unicode码,输出该unicode码对应的字符.如果某段文本中包含大量的特殊符号,FreeMarker提供了另一种特殊格式:可以在指定字符串内容的引号前增加r标记,在r标记后的文件将会直接输出.看如下代码:${r&quot;${foo}&quot;} // 输出 ${foo}${r&quot;C:/foo/bar&quot;} // 输出 C:/foo/bar include指令 1234567// include指令的作用类似于JSP的包含指令:&lt;#include &quot;/test.ftl&quot; encoding=&quot;UTF-8&quot; parse=true&gt;// 在上面的语法格式中,两个参数的解释如下:encoding=&quot;GBK&quot; // 编码格式parse=true // 是否作为ftl语法解析,默认是true，false就是以文本方式引入注意:在ftl文件里布尔值都是直接赋值的如parse=true,而不是parse=&quot;true&quot; import指令 123// 类似于jsp里的import,它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件&lt;#import &quot;/libs/mylib.ftl&quot; as my&gt;// 上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中，&quot;my&quot;在freemarker里被称作namespace compress 压缩 1234567891011// 用来压缩空白空间和空白的行 &lt;#compress&gt; ... &lt;/#compress&gt;&lt;#t&gt; // 去掉左右空白和回车换行 &lt;#lt&gt;// 去掉左边空白和回车换行 &lt;#rt&gt;// 去掉右边空白和回车换行 &lt;#nt&gt;// 取消上面的效果 escape,noescape 对字符串进行HTML编码 123456789101112// escape指令导致body区的插值都会被自动加上escape表达式,但不会影响字符串内的插值, 只会影响到body内出现的插值,使用escape指令的语法格式如下:&lt;#escape x as x?html&gt; First name: ${firstName} &lt;#noescape&gt;Last name: ${lastName}&lt;/#noescape&gt; Maiden name: ${maidenName} &lt;/#escape&gt;// 相同表达式First name: ${firstName?html} Last name: ${lastName} Maiden name: ${maidenName?html} 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950spring.freemarker.allow-request-override指定HttpServletRequest的属性是否可以覆盖controller的model的同名项spring.freemarker.allow-session-override指定HttpSession的属性是否可以覆盖controller的model的同名项spring.freemarker.cache是否开启template caching.spring.freemarker.charset设定Template的编码.spring.freemarker.check-template-location是否检查templates路径是否存在.spring.freemarker.content-type设定Content-Type.spring.freemarker.enabled是否允许mvc使用freemarker.spring.freemarker.expose-request-attributes设定所有request的属性在merge到模板的时候，是否要都添加到model中.spring.freemarker.expose-session-attributes设定所有HttpSession的属性在merge到模板的时候，是否要都添加到model中.spring.freemarker.expose-spring-macro-helpers设定是否以springMacroRequestContext的形式暴露RequestContext给Spring’s macro library使用spring.freemarker.prefer-file-system-access是否优先从文件系统加载template，以支持热加载，默认为truespring.freemarker.prefix设定freemarker模板的前缀.spring.freemarker.request-context-attribute指定RequestContext属性的名.spring.freemarker.settings设定FreeMarker keys.spring.freemarker.suffix设定模板的后缀.spring.freemarker.template-loader-path设定模板的加载路径，多个以逗号分隔，默认: [&quot;classpath:/templates/&quot;]spring.freemarker.view-names指定使用模板的视图列表.","link":"/2019/03/03/FreeMarker/"},{"title":"MyBatis-Plus","text":"在整理MyBatis时候，Mybatis的逆向工程的xml实在懒得写，找代码生成器的时候听说了MyBatis-Plus，看了看官方文档，代码生成器深得我心，对照文档学习了下，感觉效率比MyBatis提升不少。 简介MyBatis-Plus（以下简称MP）是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 代码生成器详细配置参数详见代码生成器配置，以下为我的 常用的配置。 六种ConfigDataSourceConfig 数据源配置12345678DataSourceConfig dataSource = new DataSourceConfig();dataSource.setUrl(\"jdbc:mysql://**:**/***?useUnicode=true&amp;characterEncoding=utf-8\") .setDriverName(\"com.mysql.jdbc.Driver\") .setUsername(\"**\") .setPassword(\"**\") //.setSchemaName(\"public\")//可以在Url中设置 //.setTypeConvert()//自定义类型转换（决定对应数据库内置实现） .setDbType(DbType.MYSQL);//数据库类型 MP内置的类型转换在：com.baomidou.mybatisplus.generator.config.converts，默认提供5种数据库：以MySql为例可以看到数据库对应类型与Java类型的对应：因为jdk1.8引入java.time.*新api，在日期的转换上有个通过GlobalConfig(全局配置)的参数，可以指定数据库日期类型对应的java类型转换。 StrategyConfig 策略配置123456789StrategyConfig strategy = new StrategyConfig();strategy.setNaming(NamingStrategy.underline_to_camel)//表名映射规则 .setColumnNaming(NamingStrategy.underline_to_camel)//字段名映射规则 .setEntityLombokModel(false)//【实体】是否为lombok模型（默认 false) .setEntityTableFieldAnnotationEnable(true)//实体生成字段注解 .setTablePrefix(\"test_\")//表名前缀 .setRestControllerStyle(true)//生成 @RestController 控制器 //.setExclude() .setInclude(tableNames);//需要包含的表名，允许正则表达式（与exclude二选一配置)，参数String...tablename NamingStrategy.underline_to_camel下划线转驼峰，NamingStrategy.no_change不做任何改变，原样输出。详细配置见这里 PackageConfig 包配置123456789PackageConfig pac = new PackageConfig();pac.setModuleName(modelName)//modelName .setParent(\"com.mkcorden.bootmybatisplus\")//父包名。如果为空，将下面子包名必须写全部， 否则就只需写子包名 .setController(\"controller\") .setService(\"service\") .setServiceImpl(\"service.impl\") .setMapper(\"mapper\") .setEntity(\"domain\") .setXml(\"mapper\"); 包配置时候如果要按照模块进行生成区分，一定设置modelName。ServiceImpl设置二级的目录需要注意。 TemplateConfig 模版配置1234567TemplateConfig templateConfig = new TemplateConfig();// 配置自定义输出模板// 指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别// templateConfig.setEntity(\"templates/entity2.java\");// templateConfig.setService();// templateConfig.setController();templateConfig.setXml(null); 因为静态的xml文件一般生成在resources目录下，但是按上面的包配置，.xml的mapper会直接生成在modelName/mapper/*下，在TemplateConfig下设置xml为null，则可以不输出xml文件，然后用自定义配置进行对应输出。 设置Null不输出： com.baomidou.mybatisplus.generator.config.builder.ConfigBuilder中，template.getXml()为Null，不会设置pathInfo(HashMap)中Key:xml_path的value。 在com.baomidou.mybatisplus.generator.engine.AbstractTemplateEngine的batchOutput()方法,pathInfo.get(ConstVal.XML_PATH)为null，所以不进行xml文件的输出。 GlobalConfig 全局配置12345678910111213141516GlobalConfig gc = new GlobalConfig();gc.setFileOverride(false)//文件是否覆盖上一次 .setActiveRecord(false)// 开启 activeRecord 模式 .setEnableCache(true)// XML 二级缓存 .setBaseResultMap(true)// XML ResultMap .setBaseColumnList(true)// XML columList基本的Sql片段 .setOutputDir(System.getProperty(\"user.dir\")+\"/src/main/java\") .setAuthor(\"MkCorden\") .setServiceName(\"%sService\") .setServiceImplName(\"%sServiceImpl\") .setControllerName(\"%sController\") .setMapperName(\"%sDao\") .setXmlName(\"%sDao\") .setIdType(IdType.UUID) .setOpen(false) .setDateType(DateType.ONLY_DATE);//日期类型字段对应的转换模式 %s是占位符 DateType有三种 ONLY_DATE 只使用 java.util.date 代替 SQL_PACK 使用 java.sql 包下的 TIME_PACK 使用 java.time 包下的 InjectionConfig 自定义配置1234567891011121314151617181920212223InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { //TODO }}; // 自定义输出配置List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();//String projectPath = System.getProperty(\"user.dir\");// 自定义配置会被优先输出focList.add(new FileOutConfig(\"/templates/mapper.xml.ftl\") { @Override public String outputFile(TableInfo tableInfo) { //首字母小写 char[] cs = tableInfo.getEntityName().toCharArray(); cs[0] += 32; // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return System.getProperty(\"user.dir\") + \"/src/main/resources/mapper/\" + String.valueOf(cs) + \"/\" + tableInfo.getEntityName() + \"Dao\" + StringPool.DOT_XML; }});cfg.setFileOutConfigList(focList); /templates/mapper.xml.ftl默认模版路径 与Druid集成问题 在Druid 1.1.19版本已经解决 使用Druid旧版本连接池，在使用MP代码生成器将时间类型字段映射到jdk1.8的java.time.*时，进行数据库操作对应字段会报java.sql.SQLFeatureNotSupportedException，原因具体issue见 druid:3393 / mybatis-plus:1245，解决办法又两个： 在MP的GlobalConfig中设置.setDateType(DateType.ONLY_DATE)，强制把所有时间类型转换为Date。 将MP版本将到3.1.0即可。 因为在MP ver.3.1.1加入了分布式事务特性，再一个使用新的时间格式会造成不可知的其他第三方插件不支持，综上我选第一种，哈哈。 注解使用MP自带代码生成器生成的Domain类会有@TableName @TableId @TableField注解。同时MP也提供了如@Version（乐观锁中代表版本）@TableLogic（逻辑删除中使用)，下面简单介绍几个注解，详细请参考官网文档 @TableName12@TableName(value = \"test_subject\",resultMap = \"BaseResultMap\")public class Subject implements Serializable { value：指定数据库中的表名 resultMap：指定xml中ResultMap的id keepGlobalPrefix： false（默认）：如果是 false , 全局的 tablePrefix 不生效 @TableId12@TableId(value = \"subject_id\", type = IdType.AUTO)private Long subjectId; 用于注解主键对应的属性值 value：指定主键字段名 type：指定主键的类型 AUTO：数据库自增 INPUT：自行输入 ID_WORKER：分布式全局唯一ID 长整型类型 UUID：32位UUID字符串 NONE：无状态 ID_WORKER_STR：分布式全局唯一ID 字符串类型 @TableField12@TableField(value = \"sup_subject_id\", fill = FieldFill.INSERT)private String supSubjectId; 用于注解除主键以外其他属性 value：指定对应数据库字段名 fill：自动填充策略 DEFAULT：默认不处理 INSERT：插入时填充字段 UPDATE：更新时填充字段 INSERT_UPDATE：插入和更新时填充字段 其他配置见官方文档 （公共字段）默认填充使用默认填充特性，首先要在@TableField注解内配置fill属性，然后需要实现MetaObjectHandler接口，进行自定义自动填充时候的赋值。 注意：当字段不为空时，默认填充的值会覆盖原有值。可以在填充时候进行判断，不为空时候进行填充（有点像数据库默认值），但是不建议这么做。因为每次insert和update操作都会执行我们实现的接口，所以该特性最好用于公共字段的默认填充。 12345678910111213141516171819202122232425@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler { /** * 插入元对象字段填充（用于插入时对公共字段的填充） * * @param metaObject 元对象 */ @Override public void insertFill(MetaObject metaObject) { System.out.println(\"-----------------插入方法实体填充INSERT----------------\"); setFieldValByName(\"classOverDate\", LocalDate.now().plusDays(60), metaObject); setFieldValByName(\"supSubjectId\", \"-1\", metaObject); } /** * 更新元对象字段填充（用于更新时对公共字段的填充） * * @param metaObject 元对象 */ @Override public void updateFill(MetaObject metaObject) { System.out.println(\"-----------------插入方法实体填充UPDATE----------------\"); setFieldValByName(\"classOverDate\", LocalDate.now().plusDays(70), metaObject); }} 分页插件分页时候如果设置pageSize = -1则不进行分页，如果要进行排序分页，传参数时，将排序条件封装即可，MP在Page对象中已经封装好了1234 /** * 排序字段信息 */private List&lt;OrderItem&gt; orders = new ArrayList&lt;&gt;(); 请求： 具体使用 配置 12345678910/** * 分页插件 */@Beanpublic PaginationInterceptor paginationInterceptor() { PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); //你的最大单页限制数量，默认 500 条，小于 0 如 -1 不受限制 // paginationInterceptor.setLimit(500); return paginationInterceptor;} 使用 1234567891011121314 /** * 分页 * @return */@GetMapping(\"students/page\")public ResponseEntity searchByPage(Page&lt;Student&gt; student_page, boolean listMode){ if (listMode) { // size 小于 0 不在查询 total 及分页，自动调整为列表模式。 // 注意！！这个地方自己控制好！！ student_page.setSize(-1); } IPage&lt;Student&gt; pageStudent = studentService.page(student_page); return ResponseUtil.pageSuccess(pageStudent.getTotal(),pageStudent.getRecords());} 性能分析器12345678@Bean//@Profile({\"dev\",\"test\"})// 设置 dev test 环境开启public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(1000);// 最大执行时间 performanceInterceptor.setFormat(true);// sql是否格式化 return performanceInterceptor;} 控制台效果： 默认接口CURD通过MP的代码构造器生成的Service和Dao文件，已经默认继承了com.baomidou.mybatisplus.extension.service.impl.ServiceImpl和com.baomidou.mybatisplus.core.mapper.BaseMapper,在这两文件中MP已经默认帮我们实现了一些CRUD方法。 Mapper CURD接口在启动时会自动解析实体表关系映射转换为Mybatis内部对象注入容器。 Service CRUD接口进一步封装CRUD，采用get查询单行remove删除list查询集合page分页，前缀命名方式区分Mapper层避免混淆。 业务ServiceImpl继承了MP的ServiceImpl，并注入到Controller层，所以在Controller层，对于简单的业务，可以直接调用对应方法进行返回。 条件构造器Wrapper因为使用Jdk1.8，支持lambda表达式，主要是用各种LambdaWrapper。对于在RPC模式中，不建议传输Wrapper，因为Wrapper很重。正确的方式是封装DTO进行传输，在接收端根据接收到的DTO进行相应的操作。 使用中如果入参的Map或者List为空,则不会加入最后生成的sql中!!! LambdaQueryWrapper123456789@GetMapping(\"students/search\")public ResponseEntity searchByCondition(@ModelAttribute StudentModel student_model){ //最好使用LambdaQueryWrapper,这样可以通过Student::getTrueName方式获取数据库字段名 //使用正常的QueryWrapper，需要写死字段名如\"true_name\"才可以 return ResponseUtil.success(studentService.list(new QueryWrapper&lt;Student&gt;() .lambda() .like(Student::getTrueName,student_model.getTrueName()) .between(Student::getBirthday,student_model.getBeginDate(),student_model.getEndDate())));} 上面代码中Student::getBirthday，Student为实体类，getBirthday是birthday字段的getMethod 通过QueryWrapper的.lambda()方法转换为LambdaQueryWrapper，这样可以不用将字段名写死，因为MP在处理LambdaQueryWrapper时候会通过columnToString()来转换为数据库中的字段名。 如果不能使用Lambda特性，指定字段时候，一定要写数据库中的字段名。不要写实体类的属性名。 LambdaUpdateWrapper跟QueryWrapper相似，需要注意的点是，在设置SET时候，要进行非空判断（最好直接使用已经封装的UpdateByID），因为： 例: set(“name”, “”)—&gt;数据库字段值变为空字符串 例: set(“name”, null)—&gt;数据库字段值变为null SQL注入器 与 分表分库待完成… 总结Mybatis-Plus的诸多特性，在开发中大大减少了无意义Coding的时间，同时也带来了一些不确定性，和少量的学习成本。本文学习过程中的代码已将上传到GitHub上，链接在这——&gt;","link":"/2019/08/13/MabtisPlus/"},{"title":"FreeMarker指令常用标签及语法","text":"复习FreeMarker，结合网上资料整理了一下常用的指令与语法，以备日后查看。 FreeMarker Template Language(FTL),文件一般保存为xxx.ftl。严格依赖MVC模式，不依赖Servlet容器（不占用JVM内存），使用内建函数。 注意：使用freemaker，要求所有标签必须闭合，否则会导致freemaker无法解析。freemaker注释:&lt;#– 注释内容 –&gt;格式部分,不会输出 基础语法 字符输出 1234${emp.name?if_exists} // 变量存在，输出该变量，否则不输出${emp.name!} // 变量存在，输出该变量，否则不输出${emp.name?default(&quot;xxx&quot;)} // 变量不存在，取默认值xxx ${emp.name!&quot;xxx&quot;} // 变量不存在，取默认值xxx 常用内部函数： 12345${&quot;123&lt;br&gt;456&quot;?html} // 对字符串进行HTML编码，对html中特殊字符进行转义 ${&quot;str&quot;?cap_first} // 使字符串第一个字母大写 ${&quot;Str&quot;?lower_case} // 将字符串转换成小写 ${&quot;Str&quot;?upper_case} // 将字符串转换成大写 ${&quot;str&quot;?trim} // 去掉字符串前后的空白字符 字符串的两种拼接方式拼接： 12$ { “你好$ {emp.name！}”} //输出你好+变量名 $ {“hello”+ emp.name！} //使用+号来连接，输出你好+变量名 可以通过如下语法来截取子串： 12345678&lt;#assign str =“abcdefghijklmn”/&gt;//方法1$ {str?substring（0,4）} //输出abcd//方法2 $ {str[0]}${str[4]} //结果是ae$ {str [1..4]} //结果是bcde//返回指定字符的索引$ {str?index_of（&quot;n&quot;）} 日期输出 1$ {emp.date?string（&apos;yyyy -MM-dd&apos;）} //日期格式 数字输出（以数字20为例） 123456789101112131415161718192021222324252627$ {emp.name?string.number} //输出20 $ {emp.name?string.currency} //¥20.00 $ {emp.name?string.percent} // 20％ $ {1.222？int} //将小数转为int，输出1 &lt;#setting number_format =“percent”/&gt; //设置数字默认输出方式（&apos;percent&apos;，百分比） &lt;#assign answer = 42 /&gt; //声明变量回答42 #{answer} //输出4,200％$ {answer？string} //输出4,200％$ {answer？string.number} //输出42$ {answer？string.currency} //输出¥42.00 $ {answer？string.percent} //输出4,200％#{answer} //输出42 数字格式化插值可采用＃{expr; format}形式来格式化数字，其中格式可以是：mX：小数部分最小X位MX：小数部分最大X位如下面的例子：&lt;#assign x = 2.582 /&gt; &lt;#assign y = 4 /&gt; ＃ {x; M2} //输出2.58 ＃ {y; M2} //输出4 ＃ {x; m2} //输出2.58 ＃{Y; m2} //输出4.0＃ {x; m1M2} //输出2.58 ＃ {x; m1M2} //输出4.0 申明变量 12&lt;#assign foo = false /&gt; //声明变量，插入布尔值进行显示，注意不要用引号$ {foo？string（“yes”，“no”）} //当为真时输出“yes”，否则输出“no” 申明变量的几种方式 1234567891011&lt;#assign name = value&gt; &lt;#assign name1 = value1 name2 = value2 ... nameN = valueN&gt; &lt;#assign same as above... in namespacehash&gt; &lt;#assign name&gt; capture this &lt;/＃assign&gt; &lt;#assign name in namespacehash&gt; capture this &lt;/＃assign&gt; 比较运算算符 12345表达式中支持的比较运算符符如下几个：=或==：判断两个值是否相等。！=：判断两个值是否不等。&gt;或gt：判断左边值是否大于右边值&gt;&lt;=或lte：判断左边值是否小于等于右边值 算术运算符 123456FreeMarker表达式中完全支持算术运算，FreeMarker支持的算术运算符包括：+， - ，*，/，％注意：（1）运算符两边必须是数字（2）使用+运算符时，如果一边是数字，一边是字符串，就会自动将数字转换为字符串再连接， 如：$ {3 +“5”}，结果是：35 逻辑运算符 12345逻辑运算符有如下几个：逻辑与：&amp;&amp; 逻辑或：|| 逻辑非：！逻辑运算符只能作用于布尔值，否则将产生错误 FreeMarker中的运算符优先级如下（由高到低排列）： 123456789①，一元运算符：！②，内建函数：③，乘除法：*，/，％④，加减法： - ，+ ⑤，比较：&gt;，&lt;，&gt; =，&lt;=（lt，lte，gt，gte）⑥，相等：==，=， ！= ⑦，逻辑与：&amp;&amp; ⑧，逻辑或：|| ⑨，数字范围：.. 实际上，我们在开发过程中应该使用括号来严格区分，这样的可读性好，出错少 if逻辑判断（注意：elseif不加空格） 1234567891011121314151617181920&lt;#if condition&gt;...&lt;#elseif condition2&gt;...&lt;#elseif condition3&gt;...&lt;#else&gt;...&lt;/#if&gt;if 空值判断// 当 photoList 不为空时&lt;#if photoList??&gt;...&lt;/#if&gt; 值得注意的是,${..}只能用于文本部分,不能用于表达式,下面的代码是错误的:&lt;#if ${isBig}&gt;Wow!&lt;/#if&gt;&lt;#if &quot;${isBig}&quot;&gt;Wow!&lt;/#if&gt;// 正确写法&lt;#if isBig&gt;Wow!&lt;/#if&gt; switch (条件可为数字，可为字符串) 12345678910111213&lt;#switch value&gt; &lt;#case refValue1&gt; ....&lt;#break&gt; &lt;#case refValue2&gt; ....&lt;#break&gt; &lt;#case refValueN&gt; ....&lt;#break&gt; &lt;#default&gt; .... &lt;/#switch&gt; 集合 &amp; 循环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 遍历集合:&lt;#list empList! as emp&gt; ${emp.name!}&lt;/#list&gt;// 可以这样遍历集合:&lt;#list 0..(empList!?size-1) as i&gt; ${empList[i].name!}&lt;/#list&gt;// 与jstl循环类似,也可以访问循环的状态。empList?size // 取集合的长度emp_index: // int类型，当前对象的索引值 emp_has_next: // boolean类型，是否存在下一个对象// 使用&lt;#break&gt;跳出循环&lt;#if emp_index = 0&gt;&lt;#break&gt;&lt;/#if&gt;// 集合长度判断 &lt;#if empList?size != 0&gt;&lt;/#if&gt; // 判断=的时候,注意只要一个=符号,而不是==&lt;#assign l=0..100/&gt; // 定义一个int区间的0~100的集合，数字范围也支持反递增,如100..2&lt;#list 0..100 as i&gt; // 等效于java for(int i=0; i &lt;= 100; i++) ${i}&lt;/#list&gt;// 截取子集合：empList[3..5] //返回empList集合的子集合,子集合中的元素是empList集合中的第4-6个元素// 创建集合：&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;// 集合连接运算,将两个集合连接成一个新的集合&lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;// 除此之外,集合元素也可以是表达式,例子如下:[2 + 2, [1, 2, 3, 4], &quot;whatnot&quot;]// seq_contains：判断序列中的元素是否存在&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;]&gt; ${x?seq_contains(&quot;blue&quot;)?string(&quot;yes&quot;, &quot;no&quot;)} // yes${x?seq_contains(&quot;yellow&quot;)?string(&quot;yes&quot;, &quot;no&quot;)} // no${x?seq_contains(16)?string(&quot;yes&quot;, &quot;no&quot;)} // yes${x?seq_contains(&quot;16&quot;)?string(&quot;yes&quot;, &quot;no&quot;)} // no// seq_index_of：第一次出现的索引&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;, &quot;blue&quot;]&gt; ${x?seq_index_of(&quot;blue&quot;)} // 2// sort_by：排序（升序）&lt;#list movies?sort_by(&quot;showtime&quot;) as movie&gt;&lt;/#list&gt;// sort_by：排序（降序）&lt;#list movies?sort_by(&quot;showtime&quot;)?reverse as movie&gt;&lt;/#list&gt;// 具体介绍：// 不排序的情况：&lt;#list movies as moive&gt; &lt;a href=&quot;${moive.url}&quot;&gt;${moive.name}&lt;/a&gt;&lt;/#list&gt;//要是排序，则用&lt;#list movies?sort as movie&gt; &lt;a href=&quot;${movie.url}&quot;&gt;${movie.name}&lt;/a&gt;&lt;/#list&gt;// 这是按元素的首字母排序。若要按list中对象元素的某一属性排序的话，则用&lt;#list moives?sort_by([&quot;name&quot;]) as movie&gt; &lt;a href=&quot;${movie.url}&quot;&gt;${movie.name}&lt;/a&gt;&lt;/#list&gt;//这个是按list中对象元素的[name]属性排序的，是升序，如果需要降序的话，如下所示：&lt;#list movies?sort_by([&quot;name&quot;])?reverse as movie&gt; &lt;a href=&quot;${movie.url}&quot;&gt;${movie.name}&lt;/a&gt;&lt;/#list&gt; Map对象 12345678910// 创建map&lt;#assign scores = {&quot;语文&quot;:86,&quot;数学&quot;:78}&gt;// Map连接运算符&lt;#assign scores = {&quot;语文&quot;:86,&quot;数学&quot;:78} + {&quot;数学&quot;:87,&quot;Java&quot;:93}&gt;// Map元素输出${emp.name} // 全部使用点语法${emp[&quot;name&quot;]} // 使用方括号循环//遍历集合：&lt;＃list empList！as emp&gt; $ {emp.name！} FreeMarker支持如下转义字符: 1234567891011121314151617\\&quot; ：双引号(u0022)\\&apos; ：单引号(u0027)\\\\ ：反斜杠(u005C)\\n ：换行(u000A)\\r ：回车(u000D)\\t ：Tab(u0009)\\b ：退格键(u0008)\\f ：Form feed(u000C)\\l ：&lt;\\g ：&gt;\\a ：&amp;\\{ ：{\\xCode ：直接通过4位的16进制数来指定Unicode码,输出该unicode码对应的字符.如果某段文本中包含大量的特殊符号,FreeMarker提供了另一种特殊格式:可以在指定字符串内容的引号前增加r标记,在r标记后的文件将会直接输出.看如下代码:${r&quot;${foo}&quot;} // 输出 ${foo}${r&quot;C:/foo/bar&quot;} // 输出 C:/foo/bar include指令 1234567// include指令的作用类似于JSP的包含指令:&lt;#include &quot;/test.ftl&quot; encoding=&quot;UTF-8&quot; parse=true&gt;// 在上面的语法格式中,两个参数的解释如下:encoding=&quot;GBK&quot; // 编码格式parse=true // 是否作为ftl语法解析,默认是true，false就是以文本方式引入注意:在ftl文件里布尔值都是直接赋值的如parse=true,而不是parse=&quot;true&quot; import指令 123// 类似于jsp里的import,它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件&lt;#import &quot;/libs/mylib.ftl&quot; as my&gt;// 上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中，&quot;my&quot;在freemarker里被称作namespace compress 压缩 1234567891011// 用来压缩空白空间和空白的行 &lt;#compress&gt; ... &lt;/#compress&gt;&lt;#t&gt; // 去掉左右空白和回车换行 &lt;#lt&gt;// 去掉左边空白和回车换行 &lt;#rt&gt;// 去掉右边空白和回车换行 &lt;#nt&gt;// 取消上面的效果 escape,noescape 对字符串进行HTML编码 123456789101112// escape指令导致body区的插值都会被自动加上escape表达式,但不会影响字符串内的插值, 只会影响到body内出现的插值,使用escape指令的语法格式如下:&lt;#escape x as x?html&gt; First name: ${firstName} &lt;#noescape&gt;Last name: ${lastName}&lt;/#noescape&gt; Maiden name: ${maidenName} &lt;/#escape&gt;// 相同表达式First name: ${firstName?html} Last name: ${lastName} Maiden name: ${maidenName?html} 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950spring.freemarker.allow-request-override指定HttpServletRequest的属性是否可以覆盖controller的model的同名项spring.freemarker.allow-session-override指定HttpSession的属性是否可以覆盖controller的model的同名项spring.freemarker.cache是否开启template caching.spring.freemarker.charset设定Template的编码.spring.freemarker.check-template-location是否检查templates路径是否存在.spring.freemarker.content-type设定Content-Type.spring.freemarker.enabled是否允许mvc使用freemarker.spring.freemarker.expose-request-attributes设定所有request的属性在merge到模板的时候，是否要都添加到model中.spring.freemarker.expose-session-attributes设定所有HttpSession的属性在merge到模板的时候，是否要都添加到model中.spring.freemarker.expose-spring-macro-helpers设定是否以springMacroRequestContext的形式暴露RequestContext给Spring’s macro library使用spring.freemarker.prefer-file-system-access是否优先从文件系统加载template，以支持热加载，默认为truespring.freemarker.prefix设定freemarker模板的前缀.spring.freemarker.request-context-attribute指定RequestContext属性的名.spring.freemarker.settings设定FreeMarker keys.spring.freemarker.suffix设定模板的后缀.spring.freemarker.template-loader-path设定模板的加载路径，多个以逗号分隔，默认: [&quot;classpath:/templates/&quot;]spring.freemarker.view-names指定使用模板的视图列表.","link":"/2019/03/03/media/FreeMarker/"}],"tags":[{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"备忘","slug":"备忘","link":"/tags/备忘/"}],"categories":[{"name":"MacOS相关","slug":"MacOS相关","link":"/categories/MacOS相关/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/categories/Spring-Cloud/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"}]}